<!DOCTYPE html>
<html lang="en"><head>
  <meta name="norton-safeweb-site-verification" content="90pl-9ylotk4t6ak5p4l0ybq5hiiie5na-z3q-nyea-jloyjmbxk3l3toywo-xxqy0y6-9b-oyc01k1w0-tfy8pu512c2t-weaab3exdbotwnp67mx01pmffe7ehe3-j" />
  
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <link rel="manifest" href="/manifest.webmanifest"/>
  <meta name="theme-color" content="#333"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <link rel="canonical" href="https://nickmaltbie.com"/>

  <!-- icon in the highest resolution we need it for -->
  <link rel="icon" sizes="192x192" href="logo_192.png"/>
  <!-- reuse same icon for Safari -->
  <link rel="apple-touch-icon" href="logo_512.jpg"/>
  <!-- multiple icons for IE -->
  <meta name="msapplication-square310x310logo" content="logo_310.jpg"/>

  <script async src="/assets/scripts/showMores.js"></script>
  
  <script>
  // Check that service workers are registered
  if ('serviceWorker' in navigator) {
    // Use the window load event to keep the page load performant
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('/service-worker.js');
    });
  }
  </script><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Bubble Shooter Report | Nick Maltbie</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Bubble Shooter Report" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Introduction Bubble Shooter is a simple javascript game I made. To play the game go to this page. This is my report on the project. To see the report as a pdf, click here. Table of Contents Introduction Table of Contents Description Gameplay / Instructions Implementation Game Design Class Layout Shooter Design Grid Design Collision Detection Saving the Grid in Memory Contiguous Color Identification Algorithm Bubble Design Manager Design Future Improvements Development References Description Bubble Shooter is a simple game where a player shoots bubbles at a grid to make sets. A set is three or more contiguous bubbles of the same color. When a player taps on the screen or clicks with a mouse, a bubble will be fired at the grid and attach itself to the grid. Every few shots, an extra row will be added to the grid. For every few rows that are added to the grid, new colors will be added. When the number of colors is increased, the game becomes more difficult as it is harder to make sets of three. When the number of rows reaches a certain number, the player will lose. You are just attempting to get the highest score you can, there is no win condition. This project was developed using github and the project has its own github page. Gameplay / Instructions When starting a game, you will see a view like the image below. Below are the instruction for how to play the game. When playing the game, you need to shoot from the arrow and attach bubbles to the grid. The objective of the game is to stop the balls from expanding below the red line. If the grid expands below the red line, you lose. When you click, you fill fire a ball along the path of the arrow. To move the arrow move your mouse (or finger) on the screen. When you release the mouse, the shooter will fire a ball. After firing, the ball will attach to the grid. The next ball in the shooter queue will load into the shooter and a new ball will be added to the queue. If you shoot a ball at a wall, it will bounce off the walls If when you shoot a ball, it forms a set of three or more balls, they will pop. You receive points based on the number of balls in the set ( larget sets = more points). Bubbles will only pop when a bubble is added to the grid. If bubbles disconnect from the top row, they will also pop and give extra points. After a few shots (indicated by next) a new row will be added. This will push the other rows down. If the balls reach the red line, you will lose. As new rows are added, new colors will be added When the bubbles pass the red line, you lose. Press the “full” button at the bottom of the screen to make the game fullscreen That”s the basic rules and controls of the game. Good Luck! Implementation Game Design This game is made using javascript from scratch. The source code for this project can be found on github at https://github.com/nicholas-maltbie/BubbleShooterJS. This code utilizes a html canvas to create a scene and draw elements. The game uses a draw loop to redraw and update the game at a set interval. Each one of these draw loops represents a frame. The different elements of the game are added to a list and then drawn by the main draw loop; each element is responsible for drawing itself. This functionality along with some other core features are implemented in the bubble.js file. This method had a few flaws because when I wanted to control when elements were drawn. If I wanted the arrow to appear behind the balls, I needed to add it before the bubbles. This was not practical so I used a layer system to achieve this. When adding elements, I specified a layer. Then I used this information to control the order in which elements were drawn. I used a nested hash table, the first level is the list of layers and the second level is the elements in each layer. I used a hash map to achieve fast insertion and deletion. All items, when added to the hash, are assigned an arbitrary id so they can be indexed. Drawing elements is achieved through js and an HTML5 canvas. This allows for great flexibility and cross platform implementation that is easier than making the application in another editor. Class Layout Three main objects are added to the object list and control the game. Shooter - Bubble shooter that the user uses to fire bubbles Grid = Hex grid for bubbles in the game Manager - Game manager that controls interactions between different game elements [From now on, I use the terms bubble and ball interchangeably, they mean the same thing in context of the game. I used ball in the code because it was easier to type in the code] These are all represented by different classes and have additional classes to support them. One of the more prevalent objects in the project is ball. This is the colored bubble that can move across the screen and draw itself. Below is a diagram of the interactions between classes. Shooter Design The Shooter, Manager, Grid and Ball each have their own files that describe all the classes responsibilities. Each one of these files can be found on the github project page. These classes are used to operate the game. The Manager controls the game progress. The shooter has a state machine to control when the ball can fire. It continuously updates the position of the arrow and, when allowed, fires a ball. The Manager controls when the shooter can fire. This is driven by events in the game. The shooter is the main way that a user interacts with the game. This interaction is controlled by either a mouse or by touching the screen. The wait time for the shooter reload is determined by the manager. In the game, the reload happens half a second after the fired bubble collides with the grid. I wanted this game to be playable on the phone so I decided that it would be too costly to check for collisions with every ball. A simple solution for collision detection is to check for collisions between the moving ball and every other ball on the grid. If this is done every frame with a grid (14x22 at maximum) that totals to many (over 2,000) collision checks per frame. If this is supposed to run on a mobile device, this could be rather slow. Grid Design If the grid was a square grid, a simple solution would be to check the four locations that the ball is next to on the grid. The game uses a hex grid so this solution will not work. In order to resolve this for a hex grid, I found the location closest to the ball”s current location; then I took this location and checked for collisions with the adjacent locations. This is only 7 collision checks per frame in the worst case. Collision Detection After checking for collisions, if there is a collision, find the closest location out of the adjacent and nearest locations and attach the ball to the grid at that location. Below is a diagram to show this interaction. This is implemented in the intersect_grid function in grid. Saving the Grid in Memory After a ball attaches to the grid, the manager will tell the shooter to reload and add a ball to its queue. When the shooter is finished reloading, the manager will set the shooter in the ready state. I did not use a 2d array to represent the grid can be expanded in any direction when balls are attached, rows are added, or when bubbles are popped and removed. In order to achieve these requirements, I decided to use a hash map to save each bubble by its location. Contiguous Color Identification Algorithm When attaching bubbles to the grid, the game needs to detect for contiguous groups of bubbles. If there is a contiguous group of a specific color that at the location is larger than three, the bubbles need to be removed. In order to achieve this I used a flood algorithm that uses adjacency rules of a hex grid. I had a bit of difficulty implementing a flood algorithm with recursion so I used a stack and dictionary to track new locations without repeats. This is implemented in the color_food and flood methods in the grid class. All of these rules, methods and algorithms are implemented in the Grid.js file along with many more values. Majority of these extra values are used to control the grid on screen. In addition to the contiguous color method, there is also a contiguous ball method which does not use color as a factor. This method is used to determine if a group of balls should fall. If a bubble popping separates a group of bubbles so they are not connected to the top of the row, these disconnected bubbles need to be removed. This is handled in the verify grid method in the grid.js file. If the maximum row in a group of contiguous bubbles is not the highest row, all the bubbles in that group are removed. Bubble Design One of the most important elements in the game is the bubble (Also called a ball). This is a core element and is used directly or indirectly by all other elements in the game. The bubble is just a circle on the screen that has the ability to move. There is nothing very special about the bubble but this collection of functionally into one class is necessary to the development of the game. The bubble is shared across multiple files and used to communicate between classes. One example of this communication is between the Manager and shooter. The manager loads the shooter queue with bubbles. Then the shooter loads itself with bubbles from the queue. Manager Design The manager moderates all other interactions between elements within the game. As mentioned before, the manager controls the shooter directly. Additionally, the manager controls when new rows are added to the grid, decides when the player loses, and gives the player a score. This score is determined by user actions and when a fired shot collides with the grid. One difficulty I had to overcome was making the game fullscreen. By default the game canvas is rather small so I thought I could just scale the canvas size to overcome this. This worked well but I thought I could improve it even more by adding a full screen feature. I decided to just add a full button that the user could press to activate the fullscreen. I implemented this button in the canvas so the screen would look clean without any extra html. The difficult I had was that I could not set the screen to full screen without user input. The button was a scene object and indirectly received input from the user. To fix this, I added a new category of item, buttons. These buttons would receive direct input from the user when the user clicks on the canvas. This allowed me to overcome the problem of indirect interaction with the user. This will also work on mobile platforms but is a bit off as screen resolutions vary from device to device. The last major element the manager needed to moderate was the “You Lose” panel. This panel allowed the user to restart the game and showed the player”s score. This involved making a reset function. This function removes all elements from the game and then repeats the setup code. To make the screen look nice, I needed to add a round rect function that would draw a round rectangle on the screen. This is not a default feature in JS. I looked up the algorithm online and implemented the algorithm with the help of online sources. Future Improvements If I were to do this project again, I would have made a few changes. It”s not perfect and I hope to use these lessons in the future. One of my major problems was to put more effort into design. I implemented the grid and ball from internet tutorials as this was my first major project in javascript. I did not know what to expect and just hit the ground running. Even if these classes passed my initial requirements, the requirements changed over time because I did not do enough planning before I started working. Additionally, I would have made the mouse controls better defined. The mouse is just a variable that is controlled by the bubble.js file. This lead to future problems with getting direct user input to activate or deactivate fullscreen. If I had implemented this better I could have saved many hours of troubleshooting. In the future, I would like to add more game modes as this current version just supports one mode, lose after about 50 turns. I did not put much thought into balancing the game but it is still fun. My main objective was to create a game with js, not to make a perfect game. Hopefully I will be able to use this experience to improve my future projects. Development The entire development of the project can be found on the github page. This development has a commit log and notes for each addition to the project. I maintained development on a dev branch and merged to master whenever I made a noteworthy addition. Anyone can add the game to their own website with the following html commands. &lt;div align=&quot;center&quot;&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/bubblestyle.css&quot;&gt; &lt;/link&gt; &lt;canvas id=&quot;game-canvas&quot; style=&quot;margin:0 auto; background: #eee&quot; width=&quot;480&quot; height=&quot;320&quot;&gt;&lt;/canvas&gt; &lt;script type=&quot;application/javascript&quot; src=&quot;https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/grid.js&quot;&gt; &lt;/script&gt; &lt;script type=&quot;application/javascript&quot; src=&quot;https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/ball.js&quot;&gt; &lt;/script&gt; &lt;script type=&quot;application/javascript&quot; src=&quot;https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/shooter.js&quot;&gt; &lt;/script&gt; &lt;script type=&quot;application/javascript&quot; src=&quot;https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/manager.js&quot;&gt; &lt;/script&gt; &lt;script type=&quot;application/javascript&quot; src=&quot;https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/bubbles.js&quot;&gt; &lt;/script&gt; &lt;/div&gt; An example of this can be found on my own website here References chrisdavidmills, allisonlu, fscholz, gbharatwaj, end3r, Sheppy. “Bounce off the walls”. Mozilla Development Network. Game Development. Mar 14, 2016. (source) “What Is An HTML5 Canvas”. W3Schools. 2017. (source) “Implementation of Hex Grids”. Red Blob Games. May 6th, 2016. (source)" />
<meta property="og:description" content="Introduction Bubble Shooter is a simple javascript game I made. To play the game go to this page. This is my report on the project. To see the report as a pdf, click here. Table of Contents Introduction Table of Contents Description Gameplay / Instructions Implementation Game Design Class Layout Shooter Design Grid Design Collision Detection Saving the Grid in Memory Contiguous Color Identification Algorithm Bubble Design Manager Design Future Improvements Development References Description Bubble Shooter is a simple game where a player shoots bubbles at a grid to make sets. A set is three or more contiguous bubbles of the same color. When a player taps on the screen or clicks with a mouse, a bubble will be fired at the grid and attach itself to the grid. Every few shots, an extra row will be added to the grid. For every few rows that are added to the grid, new colors will be added. When the number of colors is increased, the game becomes more difficult as it is harder to make sets of three. When the number of rows reaches a certain number, the player will lose. You are just attempting to get the highest score you can, there is no win condition. This project was developed using github and the project has its own github page. Gameplay / Instructions When starting a game, you will see a view like the image below. Below are the instruction for how to play the game. When playing the game, you need to shoot from the arrow and attach bubbles to the grid. The objective of the game is to stop the balls from expanding below the red line. If the grid expands below the red line, you lose. When you click, you fill fire a ball along the path of the arrow. To move the arrow move your mouse (or finger) on the screen. When you release the mouse, the shooter will fire a ball. After firing, the ball will attach to the grid. The next ball in the shooter queue will load into the shooter and a new ball will be added to the queue. If you shoot a ball at a wall, it will bounce off the walls If when you shoot a ball, it forms a set of three or more balls, they will pop. You receive points based on the number of balls in the set ( larget sets = more points). Bubbles will only pop when a bubble is added to the grid. If bubbles disconnect from the top row, they will also pop and give extra points. After a few shots (indicated by next) a new row will be added. This will push the other rows down. If the balls reach the red line, you will lose. As new rows are added, new colors will be added When the bubbles pass the red line, you lose. Press the “full” button at the bottom of the screen to make the game fullscreen That”s the basic rules and controls of the game. Good Luck! Implementation Game Design This game is made using javascript from scratch. The source code for this project can be found on github at https://github.com/nicholas-maltbie/BubbleShooterJS. This code utilizes a html canvas to create a scene and draw elements. The game uses a draw loop to redraw and update the game at a set interval. Each one of these draw loops represents a frame. The different elements of the game are added to a list and then drawn by the main draw loop; each element is responsible for drawing itself. This functionality along with some other core features are implemented in the bubble.js file. This method had a few flaws because when I wanted to control when elements were drawn. If I wanted the arrow to appear behind the balls, I needed to add it before the bubbles. This was not practical so I used a layer system to achieve this. When adding elements, I specified a layer. Then I used this information to control the order in which elements were drawn. I used a nested hash table, the first level is the list of layers and the second level is the elements in each layer. I used a hash map to achieve fast insertion and deletion. All items, when added to the hash, are assigned an arbitrary id so they can be indexed. Drawing elements is achieved through js and an HTML5 canvas. This allows for great flexibility and cross platform implementation that is easier than making the application in another editor. Class Layout Three main objects are added to the object list and control the game. Shooter - Bubble shooter that the user uses to fire bubbles Grid = Hex grid for bubbles in the game Manager - Game manager that controls interactions between different game elements [From now on, I use the terms bubble and ball interchangeably, they mean the same thing in context of the game. I used ball in the code because it was easier to type in the code] These are all represented by different classes and have additional classes to support them. One of the more prevalent objects in the project is ball. This is the colored bubble that can move across the screen and draw itself. Below is a diagram of the interactions between classes. Shooter Design The Shooter, Manager, Grid and Ball each have their own files that describe all the classes responsibilities. Each one of these files can be found on the github project page. These classes are used to operate the game. The Manager controls the game progress. The shooter has a state machine to control when the ball can fire. It continuously updates the position of the arrow and, when allowed, fires a ball. The Manager controls when the shooter can fire. This is driven by events in the game. The shooter is the main way that a user interacts with the game. This interaction is controlled by either a mouse or by touching the screen. The wait time for the shooter reload is determined by the manager. In the game, the reload happens half a second after the fired bubble collides with the grid. I wanted this game to be playable on the phone so I decided that it would be too costly to check for collisions with every ball. A simple solution for collision detection is to check for collisions between the moving ball and every other ball on the grid. If this is done every frame with a grid (14x22 at maximum) that totals to many (over 2,000) collision checks per frame. If this is supposed to run on a mobile device, this could be rather slow. Grid Design If the grid was a square grid, a simple solution would be to check the four locations that the ball is next to on the grid. The game uses a hex grid so this solution will not work. In order to resolve this for a hex grid, I found the location closest to the ball”s current location; then I took this location and checked for collisions with the adjacent locations. This is only 7 collision checks per frame in the worst case. Collision Detection After checking for collisions, if there is a collision, find the closest location out of the adjacent and nearest locations and attach the ball to the grid at that location. Below is a diagram to show this interaction. This is implemented in the intersect_grid function in grid. Saving the Grid in Memory After a ball attaches to the grid, the manager will tell the shooter to reload and add a ball to its queue. When the shooter is finished reloading, the manager will set the shooter in the ready state. I did not use a 2d array to represent the grid can be expanded in any direction when balls are attached, rows are added, or when bubbles are popped and removed. In order to achieve these requirements, I decided to use a hash map to save each bubble by its location. Contiguous Color Identification Algorithm When attaching bubbles to the grid, the game needs to detect for contiguous groups of bubbles. If there is a contiguous group of a specific color that at the location is larger than three, the bubbles need to be removed. In order to achieve this I used a flood algorithm that uses adjacency rules of a hex grid. I had a bit of difficulty implementing a flood algorithm with recursion so I used a stack and dictionary to track new locations without repeats. This is implemented in the color_food and flood methods in the grid class. All of these rules, methods and algorithms are implemented in the Grid.js file along with many more values. Majority of these extra values are used to control the grid on screen. In addition to the contiguous color method, there is also a contiguous ball method which does not use color as a factor. This method is used to determine if a group of balls should fall. If a bubble popping separates a group of bubbles so they are not connected to the top of the row, these disconnected bubbles need to be removed. This is handled in the verify grid method in the grid.js file. If the maximum row in a group of contiguous bubbles is not the highest row, all the bubbles in that group are removed. Bubble Design One of the most important elements in the game is the bubble (Also called a ball). This is a core element and is used directly or indirectly by all other elements in the game. The bubble is just a circle on the screen that has the ability to move. There is nothing very special about the bubble but this collection of functionally into one class is necessary to the development of the game. The bubble is shared across multiple files and used to communicate between classes. One example of this communication is between the Manager and shooter. The manager loads the shooter queue with bubbles. Then the shooter loads itself with bubbles from the queue. Manager Design The manager moderates all other interactions between elements within the game. As mentioned before, the manager controls the shooter directly. Additionally, the manager controls when new rows are added to the grid, decides when the player loses, and gives the player a score. This score is determined by user actions and when a fired shot collides with the grid. One difficulty I had to overcome was making the game fullscreen. By default the game canvas is rather small so I thought I could just scale the canvas size to overcome this. This worked well but I thought I could improve it even more by adding a full screen feature. I decided to just add a full button that the user could press to activate the fullscreen. I implemented this button in the canvas so the screen would look clean without any extra html. The difficult I had was that I could not set the screen to full screen without user input. The button was a scene object and indirectly received input from the user. To fix this, I added a new category of item, buttons. These buttons would receive direct input from the user when the user clicks on the canvas. This allowed me to overcome the problem of indirect interaction with the user. This will also work on mobile platforms but is a bit off as screen resolutions vary from device to device. The last major element the manager needed to moderate was the “You Lose” panel. This panel allowed the user to restart the game and showed the player”s score. This involved making a reset function. This function removes all elements from the game and then repeats the setup code. To make the screen look nice, I needed to add a round rect function that would draw a round rectangle on the screen. This is not a default feature in JS. I looked up the algorithm online and implemented the algorithm with the help of online sources. Future Improvements If I were to do this project again, I would have made a few changes. It”s not perfect and I hope to use these lessons in the future. One of my major problems was to put more effort into design. I implemented the grid and ball from internet tutorials as this was my first major project in javascript. I did not know what to expect and just hit the ground running. Even if these classes passed my initial requirements, the requirements changed over time because I did not do enough planning before I started working. Additionally, I would have made the mouse controls better defined. The mouse is just a variable that is controlled by the bubble.js file. This lead to future problems with getting direct user input to activate or deactivate fullscreen. If I had implemented this better I could have saved many hours of troubleshooting. In the future, I would like to add more game modes as this current version just supports one mode, lose after about 50 turns. I did not put much thought into balancing the game but it is still fun. My main objective was to create a game with js, not to make a perfect game. Hopefully I will be able to use this experience to improve my future projects. Development The entire development of the project can be found on the github page. This development has a commit log and notes for each addition to the project. I maintained development on a dev branch and merged to master whenever I made a noteworthy addition. Anyone can add the game to their own website with the following html commands. &lt;div align=&quot;center&quot;&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/bubblestyle.css&quot;&gt; &lt;/link&gt; &lt;canvas id=&quot;game-canvas&quot; style=&quot;margin:0 auto; background: #eee&quot; width=&quot;480&quot; height=&quot;320&quot;&gt;&lt;/canvas&gt; &lt;script type=&quot;application/javascript&quot; src=&quot;https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/grid.js&quot;&gt; &lt;/script&gt; &lt;script type=&quot;application/javascript&quot; src=&quot;https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/ball.js&quot;&gt; &lt;/script&gt; &lt;script type=&quot;application/javascript&quot; src=&quot;https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/shooter.js&quot;&gt; &lt;/script&gt; &lt;script type=&quot;application/javascript&quot; src=&quot;https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/manager.js&quot;&gt; &lt;/script&gt; &lt;script type=&quot;application/javascript&quot; src=&quot;https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/bubbles.js&quot;&gt; &lt;/script&gt; &lt;/div&gt; An example of this can be found on my own website here References chrisdavidmills, allisonlu, fscholz, gbharatwaj, end3r, Sheppy. “Bounce off the walls”. Mozilla Development Network. Game Development. Mar 14, 2016. (source) “What Is An HTML5 Canvas”. W3Schools. 2017. (source) “Implementation of Hex Grids”. Red Blob Games. May 6th, 2016. (source)" />
<link rel="canonical" href="https://nickmaltbie.com/bubble/report" />
<meta property="og:url" content="https://nickmaltbie.com/bubble/report" />
<meta property="og:site_name" content="Nick Maltbie" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-04-01T00:00:00+00:00" />
<script type="application/ld+json">
{"description":"Introduction Bubble Shooter is a simple javascript game I made. To play the game go to this page. This is my report on the project. To see the report as a pdf, click here. Table of Contents Introduction Table of Contents Description Gameplay / Instructions Implementation Game Design Class Layout Shooter Design Grid Design Collision Detection Saving the Grid in Memory Contiguous Color Identification Algorithm Bubble Design Manager Design Future Improvements Development References Description Bubble Shooter is a simple game where a player shoots bubbles at a grid to make sets. A set is three or more contiguous bubbles of the same color. When a player taps on the screen or clicks with a mouse, a bubble will be fired at the grid and attach itself to the grid. Every few shots, an extra row will be added to the grid. For every few rows that are added to the grid, new colors will be added. When the number of colors is increased, the game becomes more difficult as it is harder to make sets of three. When the number of rows reaches a certain number, the player will lose. You are just attempting to get the highest score you can, there is no win condition. This project was developed using github and the project has its own github page. Gameplay / Instructions When starting a game, you will see a view like the image below. Below are the instruction for how to play the game. When playing the game, you need to shoot from the arrow and attach bubbles to the grid. The objective of the game is to stop the balls from expanding below the red line. If the grid expands below the red line, you lose. When you click, you fill fire a ball along the path of the arrow. To move the arrow move your mouse (or finger) on the screen. When you release the mouse, the shooter will fire a ball. After firing, the ball will attach to the grid. The next ball in the shooter queue will load into the shooter and a new ball will be added to the queue. If you shoot a ball at a wall, it will bounce off the walls If when you shoot a ball, it forms a set of three or more balls, they will pop. You receive points based on the number of balls in the set ( larget sets = more points). Bubbles will only pop when a bubble is added to the grid. If bubbles disconnect from the top row, they will also pop and give extra points. After a few shots (indicated by next) a new row will be added. This will push the other rows down. If the balls reach the red line, you will lose. As new rows are added, new colors will be added When the bubbles pass the red line, you lose. Press the “full” button at the bottom of the screen to make the game fullscreen That”s the basic rules and controls of the game. Good Luck! Implementation Game Design This game is made using javascript from scratch. The source code for this project can be found on github at https://github.com/nicholas-maltbie/BubbleShooterJS. This code utilizes a html canvas to create a scene and draw elements. The game uses a draw loop to redraw and update the game at a set interval. Each one of these draw loops represents a frame. The different elements of the game are added to a list and then drawn by the main draw loop; each element is responsible for drawing itself. This functionality along with some other core features are implemented in the bubble.js file. This method had a few flaws because when I wanted to control when elements were drawn. If I wanted the arrow to appear behind the balls, I needed to add it before the bubbles. This was not practical so I used a layer system to achieve this. When adding elements, I specified a layer. Then I used this information to control the order in which elements were drawn. I used a nested hash table, the first level is the list of layers and the second level is the elements in each layer. I used a hash map to achieve fast insertion and deletion. All items, when added to the hash, are assigned an arbitrary id so they can be indexed. Drawing elements is achieved through js and an HTML5 canvas. This allows for great flexibility and cross platform implementation that is easier than making the application in another editor. Class Layout Three main objects are added to the object list and control the game. Shooter - Bubble shooter that the user uses to fire bubbles Grid = Hex grid for bubbles in the game Manager - Game manager that controls interactions between different game elements [From now on, I use the terms bubble and ball interchangeably, they mean the same thing in context of the game. I used ball in the code because it was easier to type in the code] These are all represented by different classes and have additional classes to support them. One of the more prevalent objects in the project is ball. This is the colored bubble that can move across the screen and draw itself. Below is a diagram of the interactions between classes. Shooter Design The Shooter, Manager, Grid and Ball each have their own files that describe all the classes responsibilities. Each one of these files can be found on the github project page. These classes are used to operate the game. The Manager controls the game progress. The shooter has a state machine to control when the ball can fire. It continuously updates the position of the arrow and, when allowed, fires a ball. The Manager controls when the shooter can fire. This is driven by events in the game. The shooter is the main way that a user interacts with the game. This interaction is controlled by either a mouse or by touching the screen. The wait time for the shooter reload is determined by the manager. In the game, the reload happens half a second after the fired bubble collides with the grid. I wanted this game to be playable on the phone so I decided that it would be too costly to check for collisions with every ball. A simple solution for collision detection is to check for collisions between the moving ball and every other ball on the grid. If this is done every frame with a grid (14x22 at maximum) that totals to many (over 2,000) collision checks per frame. If this is supposed to run on a mobile device, this could be rather slow. Grid Design If the grid was a square grid, a simple solution would be to check the four locations that the ball is next to on the grid. The game uses a hex grid so this solution will not work. In order to resolve this for a hex grid, I found the location closest to the ball”s current location; then I took this location and checked for collisions with the adjacent locations. This is only 7 collision checks per frame in the worst case. Collision Detection After checking for collisions, if there is a collision, find the closest location out of the adjacent and nearest locations and attach the ball to the grid at that location. Below is a diagram to show this interaction. This is implemented in the intersect_grid function in grid. Saving the Grid in Memory After a ball attaches to the grid, the manager will tell the shooter to reload and add a ball to its queue. When the shooter is finished reloading, the manager will set the shooter in the ready state. I did not use a 2d array to represent the grid can be expanded in any direction when balls are attached, rows are added, or when bubbles are popped and removed. In order to achieve these requirements, I decided to use a hash map to save each bubble by its location. Contiguous Color Identification Algorithm When attaching bubbles to the grid, the game needs to detect for contiguous groups of bubbles. If there is a contiguous group of a specific color that at the location is larger than three, the bubbles need to be removed. In order to achieve this I used a flood algorithm that uses adjacency rules of a hex grid. I had a bit of difficulty implementing a flood algorithm with recursion so I used a stack and dictionary to track new locations without repeats. This is implemented in the color_food and flood methods in the grid class. All of these rules, methods and algorithms are implemented in the Grid.js file along with many more values. Majority of these extra values are used to control the grid on screen. In addition to the contiguous color method, there is also a contiguous ball method which does not use color as a factor. This method is used to determine if a group of balls should fall. If a bubble popping separates a group of bubbles so they are not connected to the top of the row, these disconnected bubbles need to be removed. This is handled in the verify grid method in the grid.js file. If the maximum row in a group of contiguous bubbles is not the highest row, all the bubbles in that group are removed. Bubble Design One of the most important elements in the game is the bubble (Also called a ball). This is a core element and is used directly or indirectly by all other elements in the game. The bubble is just a circle on the screen that has the ability to move. There is nothing very special about the bubble but this collection of functionally into one class is necessary to the development of the game. The bubble is shared across multiple files and used to communicate between classes. One example of this communication is between the Manager and shooter. The manager loads the shooter queue with bubbles. Then the shooter loads itself with bubbles from the queue. Manager Design The manager moderates all other interactions between elements within the game. As mentioned before, the manager controls the shooter directly. Additionally, the manager controls when new rows are added to the grid, decides when the player loses, and gives the player a score. This score is determined by user actions and when a fired shot collides with the grid. One difficulty I had to overcome was making the game fullscreen. By default the game canvas is rather small so I thought I could just scale the canvas size to overcome this. This worked well but I thought I could improve it even more by adding a full screen feature. I decided to just add a full button that the user could press to activate the fullscreen. I implemented this button in the canvas so the screen would look clean without any extra html. The difficult I had was that I could not set the screen to full screen without user input. The button was a scene object and indirectly received input from the user. To fix this, I added a new category of item, buttons. These buttons would receive direct input from the user when the user clicks on the canvas. This allowed me to overcome the problem of indirect interaction with the user. This will also work on mobile platforms but is a bit off as screen resolutions vary from device to device. The last major element the manager needed to moderate was the “You Lose” panel. This panel allowed the user to restart the game and showed the player”s score. This involved making a reset function. This function removes all elements from the game and then repeats the setup code. To make the screen look nice, I needed to add a round rect function that would draw a round rectangle on the screen. This is not a default feature in JS. I looked up the algorithm online and implemented the algorithm with the help of online sources. Future Improvements If I were to do this project again, I would have made a few changes. It”s not perfect and I hope to use these lessons in the future. One of my major problems was to put more effort into design. I implemented the grid and ball from internet tutorials as this was my first major project in javascript. I did not know what to expect and just hit the ground running. Even if these classes passed my initial requirements, the requirements changed over time because I did not do enough planning before I started working. Additionally, I would have made the mouse controls better defined. The mouse is just a variable that is controlled by the bubble.js file. This lead to future problems with getting direct user input to activate or deactivate fullscreen. If I had implemented this better I could have saved many hours of troubleshooting. In the future, I would like to add more game modes as this current version just supports one mode, lose after about 50 turns. I did not put much thought into balancing the game but it is still fun. My main objective was to create a game with js, not to make a perfect game. Hopefully I will be able to use this experience to improve my future projects. Development The entire development of the project can be found on the github page. This development has a commit log and notes for each addition to the project. I maintained development on a dev branch and merged to master whenever I made a noteworthy addition. Anyone can add the game to their own website with the following html commands. &lt;div align=&quot;center&quot;&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/bubblestyle.css&quot;&gt; &lt;/link&gt; &lt;canvas id=&quot;game-canvas&quot; style=&quot;margin:0 auto; background: #eee&quot; width=&quot;480&quot; height=&quot;320&quot;&gt;&lt;/canvas&gt; &lt;script type=&quot;application/javascript&quot; src=&quot;https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/grid.js&quot;&gt; &lt;/script&gt; &lt;script type=&quot;application/javascript&quot; src=&quot;https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/ball.js&quot;&gt; &lt;/script&gt; &lt;script type=&quot;application/javascript&quot; src=&quot;https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/shooter.js&quot;&gt; &lt;/script&gt; &lt;script type=&quot;application/javascript&quot; src=&quot;https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/manager.js&quot;&gt; &lt;/script&gt; &lt;script type=&quot;application/javascript&quot; src=&quot;https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/bubbles.js&quot;&gt; &lt;/script&gt; &lt;/div&gt; An example of this can be found on my own website here References chrisdavidmills, allisonlu, fscholz, gbharatwaj, end3r, Sheppy. “Bounce off the walls”. Mozilla Development Network. Game Development. Mar 14, 2016. (source) “What Is An HTML5 Canvas”. W3Schools. 2017. (source) “Implementation of Hex Grids”. Red Blob Games. May 6th, 2016. (source)","url":"https://nickmaltbie.com/bubble/report","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://nickmaltbie.com/bubble/report"},"headline":"Bubble Shooter Report","dateModified":"2017-04-01T00:00:00+00:00","datePublished":"2017-04-01T00:00:00+00:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link async rel="stylesheet" href="/assets/main.css"/><link type="application/atom+xml" rel="alternate" href="https://nickmaltbie.com/feed.xml" title="Nick Maltbie" /><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Bubble Shooter Report | Nick Maltbie</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Bubble Shooter Report" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Introduction Bubble Shooter is a simple javascript game I made. To play the game go to this page. This is my report on the project. To see the report as a pdf, click here. Table of Contents Introduction Table of Contents Description Gameplay / Instructions Implementation Game Design Class Layout Shooter Design Grid Design Collision Detection Saving the Grid in Memory Contiguous Color Identification Algorithm Bubble Design Manager Design Future Improvements Development References Description Bubble Shooter is a simple game where a player shoots bubbles at a grid to make sets. A set is three or more contiguous bubbles of the same color. When a player taps on the screen or clicks with a mouse, a bubble will be fired at the grid and attach itself to the grid. Every few shots, an extra row will be added to the grid. For every few rows that are added to the grid, new colors will be added. When the number of colors is increased, the game becomes more difficult as it is harder to make sets of three. When the number of rows reaches a certain number, the player will lose. You are just attempting to get the highest score you can, there is no win condition. This project was developed using github and the project has its own github page. Gameplay / Instructions When starting a game, you will see a view like the image below. Below are the instruction for how to play the game. When playing the game, you need to shoot from the arrow and attach bubbles to the grid. The objective of the game is to stop the balls from expanding below the red line. If the grid expands below the red line, you lose. When you click, you fill fire a ball along the path of the arrow. To move the arrow move your mouse (or finger) on the screen. When you release the mouse, the shooter will fire a ball. After firing, the ball will attach to the grid. The next ball in the shooter queue will load into the shooter and a new ball will be added to the queue. If you shoot a ball at a wall, it will bounce off the walls If when you shoot a ball, it forms a set of three or more balls, they will pop. You receive points based on the number of balls in the set ( larget sets = more points). Bubbles will only pop when a bubble is added to the grid. If bubbles disconnect from the top row, they will also pop and give extra points. After a few shots (indicated by next) a new row will be added. This will push the other rows down. If the balls reach the red line, you will lose. As new rows are added, new colors will be added When the bubbles pass the red line, you lose. Press the “full” button at the bottom of the screen to make the game fullscreen That”s the basic rules and controls of the game. Good Luck! Implementation Game Design This game is made using javascript from scratch. The source code for this project can be found on github at https://github.com/nicholas-maltbie/BubbleShooterJS. This code utilizes a html canvas to create a scene and draw elements. The game uses a draw loop to redraw and update the game at a set interval. Each one of these draw loops represents a frame. The different elements of the game are added to a list and then drawn by the main draw loop; each element is responsible for drawing itself. This functionality along with some other core features are implemented in the bubble.js file. This method had a few flaws because when I wanted to control when elements were drawn. If I wanted the arrow to appear behind the balls, I needed to add it before the bubbles. This was not practical so I used a layer system to achieve this. When adding elements, I specified a layer. Then I used this information to control the order in which elements were drawn. I used a nested hash table, the first level is the list of layers and the second level is the elements in each layer. I used a hash map to achieve fast insertion and deletion. All items, when added to the hash, are assigned an arbitrary id so they can be indexed. Drawing elements is achieved through js and an HTML5 canvas. This allows for great flexibility and cross platform implementation that is easier than making the application in another editor. Class Layout Three main objects are added to the object list and control the game. Shooter - Bubble shooter that the user uses to fire bubbles Grid = Hex grid for bubbles in the game Manager - Game manager that controls interactions between different game elements [From now on, I use the terms bubble and ball interchangeably, they mean the same thing in context of the game. I used ball in the code because it was easier to type in the code] These are all represented by different classes and have additional classes to support them. One of the more prevalent objects in the project is ball. This is the colored bubble that can move across the screen and draw itself. Below is a diagram of the interactions between classes. Shooter Design The Shooter, Manager, Grid and Ball each have their own files that describe all the classes responsibilities. Each one of these files can be found on the github project page. These classes are used to operate the game. The Manager controls the game progress. The shooter has a state machine to control when the ball can fire. It continuously updates the position of the arrow and, when allowed, fires a ball. The Manager controls when the shooter can fire. This is driven by events in the game. The shooter is the main way that a user interacts with the game. This interaction is controlled by either a mouse or by touching the screen. The wait time for the shooter reload is determined by the manager. In the game, the reload happens half a second after the fired bubble collides with the grid. I wanted this game to be playable on the phone so I decided that it would be too costly to check for collisions with every ball. A simple solution for collision detection is to check for collisions between the moving ball and every other ball on the grid. If this is done every frame with a grid (14x22 at maximum) that totals to many (over 2,000) collision checks per frame. If this is supposed to run on a mobile device, this could be rather slow. Grid Design If the grid was a square grid, a simple solution would be to check the four locations that the ball is next to on the grid. The game uses a hex grid so this solution will not work. In order to resolve this for a hex grid, I found the location closest to the ball”s current location; then I took this location and checked for collisions with the adjacent locations. This is only 7 collision checks per frame in the worst case. Collision Detection After checking for collisions, if there is a collision, find the closest location out of the adjacent and nearest locations and attach the ball to the grid at that location. Below is a diagram to show this interaction. This is implemented in the intersect_grid function in grid. Saving the Grid in Memory After a ball attaches to the grid, the manager will tell the shooter to reload and add a ball to its queue. When the shooter is finished reloading, the manager will set the shooter in the ready state. I did not use a 2d array to represent the grid can be expanded in any direction when balls are attached, rows are added, or when bubbles are popped and removed. In order to achieve these requirements, I decided to use a hash map to save each bubble by its location. Contiguous Color Identification Algorithm When attaching bubbles to the grid, the game needs to detect for contiguous groups of bubbles. If there is a contiguous group of a specific color that at the location is larger than three, the bubbles need to be removed. In order to achieve this I used a flood algorithm that uses adjacency rules of a hex grid. I had a bit of difficulty implementing a flood algorithm with recursion so I used a stack and dictionary to track new locations without repeats. This is implemented in the color_food and flood methods in the grid class. All of these rules, methods and algorithms are implemented in the Grid.js file along with many more values. Majority of these extra values are used to control the grid on screen. In addition to the contiguous color method, there is also a contiguous ball method which does not use color as a factor. This method is used to determine if a group of balls should fall. If a bubble popping separates a group of bubbles so they are not connected to the top of the row, these disconnected bubbles need to be removed. This is handled in the verify grid method in the grid.js file. If the maximum row in a group of contiguous bubbles is not the highest row, all the bubbles in that group are removed. Bubble Design One of the most important elements in the game is the bubble (Also called a ball). This is a core element and is used directly or indirectly by all other elements in the game. The bubble is just a circle on the screen that has the ability to move. There is nothing very special about the bubble but this collection of functionally into one class is necessary to the development of the game. The bubble is shared across multiple files and used to communicate between classes. One example of this communication is between the Manager and shooter. The manager loads the shooter queue with bubbles. Then the shooter loads itself with bubbles from the queue. Manager Design The manager moderates all other interactions between elements within the game. As mentioned before, the manager controls the shooter directly. Additionally, the manager controls when new rows are added to the grid, decides when the player loses, and gives the player a score. This score is determined by user actions and when a fired shot collides with the grid. One difficulty I had to overcome was making the game fullscreen. By default the game canvas is rather small so I thought I could just scale the canvas size to overcome this. This worked well but I thought I could improve it even more by adding a full screen feature. I decided to just add a full button that the user could press to activate the fullscreen. I implemented this button in the canvas so the screen would look clean without any extra html. The difficult I had was that I could not set the screen to full screen without user input. The button was a scene object and indirectly received input from the user. To fix this, I added a new category of item, buttons. These buttons would receive direct input from the user when the user clicks on the canvas. This allowed me to overcome the problem of indirect interaction with the user. This will also work on mobile platforms but is a bit off as screen resolutions vary from device to device. The last major element the manager needed to moderate was the “You Lose” panel. This panel allowed the user to restart the game and showed the player”s score. This involved making a reset function. This function removes all elements from the game and then repeats the setup code. To make the screen look nice, I needed to add a round rect function that would draw a round rectangle on the screen. This is not a default feature in JS. I looked up the algorithm online and implemented the algorithm with the help of online sources. Future Improvements If I were to do this project again, I would have made a few changes. It”s not perfect and I hope to use these lessons in the future. One of my major problems was to put more effort into design. I implemented the grid and ball from internet tutorials as this was my first major project in javascript. I did not know what to expect and just hit the ground running. Even if these classes passed my initial requirements, the requirements changed over time because I did not do enough planning before I started working. Additionally, I would have made the mouse controls better defined. The mouse is just a variable that is controlled by the bubble.js file. This lead to future problems with getting direct user input to activate or deactivate fullscreen. If I had implemented this better I could have saved many hours of troubleshooting. In the future, I would like to add more game modes as this current version just supports one mode, lose after about 50 turns. I did not put much thought into balancing the game but it is still fun. My main objective was to create a game with js, not to make a perfect game. Hopefully I will be able to use this experience to improve my future projects. Development The entire development of the project can be found on the github page. This development has a commit log and notes for each addition to the project. I maintained development on a dev branch and merged to master whenever I made a noteworthy addition. Anyone can add the game to their own website with the following html commands. &lt;div align=&quot;center&quot;&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/bubblestyle.css&quot;&gt; &lt;/link&gt; &lt;canvas id=&quot;game-canvas&quot; style=&quot;margin:0 auto; background: #eee&quot; width=&quot;480&quot; height=&quot;320&quot;&gt;&lt;/canvas&gt; &lt;script type=&quot;application/javascript&quot; src=&quot;https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/grid.js&quot;&gt; &lt;/script&gt; &lt;script type=&quot;application/javascript&quot; src=&quot;https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/ball.js&quot;&gt; &lt;/script&gt; &lt;script type=&quot;application/javascript&quot; src=&quot;https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/shooter.js&quot;&gt; &lt;/script&gt; &lt;script type=&quot;application/javascript&quot; src=&quot;https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/manager.js&quot;&gt; &lt;/script&gt; &lt;script type=&quot;application/javascript&quot; src=&quot;https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/bubbles.js&quot;&gt; &lt;/script&gt; &lt;/div&gt; An example of this can be found on my own website here References chrisdavidmills, allisonlu, fscholz, gbharatwaj, end3r, Sheppy. “Bounce off the walls”. Mozilla Development Network. Game Development. Mar 14, 2016. (source) “What Is An HTML5 Canvas”. W3Schools. 2017. (source) “Implementation of Hex Grids”. Red Blob Games. May 6th, 2016. (source)" />
<meta property="og:description" content="Introduction Bubble Shooter is a simple javascript game I made. To play the game go to this page. This is my report on the project. To see the report as a pdf, click here. Table of Contents Introduction Table of Contents Description Gameplay / Instructions Implementation Game Design Class Layout Shooter Design Grid Design Collision Detection Saving the Grid in Memory Contiguous Color Identification Algorithm Bubble Design Manager Design Future Improvements Development References Description Bubble Shooter is a simple game where a player shoots bubbles at a grid to make sets. A set is three or more contiguous bubbles of the same color. When a player taps on the screen or clicks with a mouse, a bubble will be fired at the grid and attach itself to the grid. Every few shots, an extra row will be added to the grid. For every few rows that are added to the grid, new colors will be added. When the number of colors is increased, the game becomes more difficult as it is harder to make sets of three. When the number of rows reaches a certain number, the player will lose. You are just attempting to get the highest score you can, there is no win condition. This project was developed using github and the project has its own github page. Gameplay / Instructions When starting a game, you will see a view like the image below. Below are the instruction for how to play the game. When playing the game, you need to shoot from the arrow and attach bubbles to the grid. The objective of the game is to stop the balls from expanding below the red line. If the grid expands below the red line, you lose. When you click, you fill fire a ball along the path of the arrow. To move the arrow move your mouse (or finger) on the screen. When you release the mouse, the shooter will fire a ball. After firing, the ball will attach to the grid. The next ball in the shooter queue will load into the shooter and a new ball will be added to the queue. If you shoot a ball at a wall, it will bounce off the walls If when you shoot a ball, it forms a set of three or more balls, they will pop. You receive points based on the number of balls in the set ( larget sets = more points). Bubbles will only pop when a bubble is added to the grid. If bubbles disconnect from the top row, they will also pop and give extra points. After a few shots (indicated by next) a new row will be added. This will push the other rows down. If the balls reach the red line, you will lose. As new rows are added, new colors will be added When the bubbles pass the red line, you lose. Press the “full” button at the bottom of the screen to make the game fullscreen That”s the basic rules and controls of the game. Good Luck! Implementation Game Design This game is made using javascript from scratch. The source code for this project can be found on github at https://github.com/nicholas-maltbie/BubbleShooterJS. This code utilizes a html canvas to create a scene and draw elements. The game uses a draw loop to redraw and update the game at a set interval. Each one of these draw loops represents a frame. The different elements of the game are added to a list and then drawn by the main draw loop; each element is responsible for drawing itself. This functionality along with some other core features are implemented in the bubble.js file. This method had a few flaws because when I wanted to control when elements were drawn. If I wanted the arrow to appear behind the balls, I needed to add it before the bubbles. This was not practical so I used a layer system to achieve this. When adding elements, I specified a layer. Then I used this information to control the order in which elements were drawn. I used a nested hash table, the first level is the list of layers and the second level is the elements in each layer. I used a hash map to achieve fast insertion and deletion. All items, when added to the hash, are assigned an arbitrary id so they can be indexed. Drawing elements is achieved through js and an HTML5 canvas. This allows for great flexibility and cross platform implementation that is easier than making the application in another editor. Class Layout Three main objects are added to the object list and control the game. Shooter - Bubble shooter that the user uses to fire bubbles Grid = Hex grid for bubbles in the game Manager - Game manager that controls interactions between different game elements [From now on, I use the terms bubble and ball interchangeably, they mean the same thing in context of the game. I used ball in the code because it was easier to type in the code] These are all represented by different classes and have additional classes to support them. One of the more prevalent objects in the project is ball. This is the colored bubble that can move across the screen and draw itself. Below is a diagram of the interactions between classes. Shooter Design The Shooter, Manager, Grid and Ball each have their own files that describe all the classes responsibilities. Each one of these files can be found on the github project page. These classes are used to operate the game. The Manager controls the game progress. The shooter has a state machine to control when the ball can fire. It continuously updates the position of the arrow and, when allowed, fires a ball. The Manager controls when the shooter can fire. This is driven by events in the game. The shooter is the main way that a user interacts with the game. This interaction is controlled by either a mouse or by touching the screen. The wait time for the shooter reload is determined by the manager. In the game, the reload happens half a second after the fired bubble collides with the grid. I wanted this game to be playable on the phone so I decided that it would be too costly to check for collisions with every ball. A simple solution for collision detection is to check for collisions between the moving ball and every other ball on the grid. If this is done every frame with a grid (14x22 at maximum) that totals to many (over 2,000) collision checks per frame. If this is supposed to run on a mobile device, this could be rather slow. Grid Design If the grid was a square grid, a simple solution would be to check the four locations that the ball is next to on the grid. The game uses a hex grid so this solution will not work. In order to resolve this for a hex grid, I found the location closest to the ball”s current location; then I took this location and checked for collisions with the adjacent locations. This is only 7 collision checks per frame in the worst case. Collision Detection After checking for collisions, if there is a collision, find the closest location out of the adjacent and nearest locations and attach the ball to the grid at that location. Below is a diagram to show this interaction. This is implemented in the intersect_grid function in grid. Saving the Grid in Memory After a ball attaches to the grid, the manager will tell the shooter to reload and add a ball to its queue. When the shooter is finished reloading, the manager will set the shooter in the ready state. I did not use a 2d array to represent the grid can be expanded in any direction when balls are attached, rows are added, or when bubbles are popped and removed. In order to achieve these requirements, I decided to use a hash map to save each bubble by its location. Contiguous Color Identification Algorithm When attaching bubbles to the grid, the game needs to detect for contiguous groups of bubbles. If there is a contiguous group of a specific color that at the location is larger than three, the bubbles need to be removed. In order to achieve this I used a flood algorithm that uses adjacency rules of a hex grid. I had a bit of difficulty implementing a flood algorithm with recursion so I used a stack and dictionary to track new locations without repeats. This is implemented in the color_food and flood methods in the grid class. All of these rules, methods and algorithms are implemented in the Grid.js file along with many more values. Majority of these extra values are used to control the grid on screen. In addition to the contiguous color method, there is also a contiguous ball method which does not use color as a factor. This method is used to determine if a group of balls should fall. If a bubble popping separates a group of bubbles so they are not connected to the top of the row, these disconnected bubbles need to be removed. This is handled in the verify grid method in the grid.js file. If the maximum row in a group of contiguous bubbles is not the highest row, all the bubbles in that group are removed. Bubble Design One of the most important elements in the game is the bubble (Also called a ball). This is a core element and is used directly or indirectly by all other elements in the game. The bubble is just a circle on the screen that has the ability to move. There is nothing very special about the bubble but this collection of functionally into one class is necessary to the development of the game. The bubble is shared across multiple files and used to communicate between classes. One example of this communication is between the Manager and shooter. The manager loads the shooter queue with bubbles. Then the shooter loads itself with bubbles from the queue. Manager Design The manager moderates all other interactions between elements within the game. As mentioned before, the manager controls the shooter directly. Additionally, the manager controls when new rows are added to the grid, decides when the player loses, and gives the player a score. This score is determined by user actions and when a fired shot collides with the grid. One difficulty I had to overcome was making the game fullscreen. By default the game canvas is rather small so I thought I could just scale the canvas size to overcome this. This worked well but I thought I could improve it even more by adding a full screen feature. I decided to just add a full button that the user could press to activate the fullscreen. I implemented this button in the canvas so the screen would look clean without any extra html. The difficult I had was that I could not set the screen to full screen without user input. The button was a scene object and indirectly received input from the user. To fix this, I added a new category of item, buttons. These buttons would receive direct input from the user when the user clicks on the canvas. This allowed me to overcome the problem of indirect interaction with the user. This will also work on mobile platforms but is a bit off as screen resolutions vary from device to device. The last major element the manager needed to moderate was the “You Lose” panel. This panel allowed the user to restart the game and showed the player”s score. This involved making a reset function. This function removes all elements from the game and then repeats the setup code. To make the screen look nice, I needed to add a round rect function that would draw a round rectangle on the screen. This is not a default feature in JS. I looked up the algorithm online and implemented the algorithm with the help of online sources. Future Improvements If I were to do this project again, I would have made a few changes. It”s not perfect and I hope to use these lessons in the future. One of my major problems was to put more effort into design. I implemented the grid and ball from internet tutorials as this was my first major project in javascript. I did not know what to expect and just hit the ground running. Even if these classes passed my initial requirements, the requirements changed over time because I did not do enough planning before I started working. Additionally, I would have made the mouse controls better defined. The mouse is just a variable that is controlled by the bubble.js file. This lead to future problems with getting direct user input to activate or deactivate fullscreen. If I had implemented this better I could have saved many hours of troubleshooting. In the future, I would like to add more game modes as this current version just supports one mode, lose after about 50 turns. I did not put much thought into balancing the game but it is still fun. My main objective was to create a game with js, not to make a perfect game. Hopefully I will be able to use this experience to improve my future projects. Development The entire development of the project can be found on the github page. This development has a commit log and notes for each addition to the project. I maintained development on a dev branch and merged to master whenever I made a noteworthy addition. Anyone can add the game to their own website with the following html commands. &lt;div align=&quot;center&quot;&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/bubblestyle.css&quot;&gt; &lt;/link&gt; &lt;canvas id=&quot;game-canvas&quot; style=&quot;margin:0 auto; background: #eee&quot; width=&quot;480&quot; height=&quot;320&quot;&gt;&lt;/canvas&gt; &lt;script type=&quot;application/javascript&quot; src=&quot;https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/grid.js&quot;&gt; &lt;/script&gt; &lt;script type=&quot;application/javascript&quot; src=&quot;https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/ball.js&quot;&gt; &lt;/script&gt; &lt;script type=&quot;application/javascript&quot; src=&quot;https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/shooter.js&quot;&gt; &lt;/script&gt; &lt;script type=&quot;application/javascript&quot; src=&quot;https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/manager.js&quot;&gt; &lt;/script&gt; &lt;script type=&quot;application/javascript&quot; src=&quot;https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/bubbles.js&quot;&gt; &lt;/script&gt; &lt;/div&gt; An example of this can be found on my own website here References chrisdavidmills, allisonlu, fscholz, gbharatwaj, end3r, Sheppy. “Bounce off the walls”. Mozilla Development Network. Game Development. Mar 14, 2016. (source) “What Is An HTML5 Canvas”. W3Schools. 2017. (source) “Implementation of Hex Grids”. Red Blob Games. May 6th, 2016. (source)" />
<link rel="canonical" href="https://nickmaltbie.com/bubble/report" />
<meta property="og:url" content="https://nickmaltbie.com/bubble/report" />
<meta property="og:site_name" content="Nick Maltbie" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-04-01T00:00:00+00:00" />
<script type="application/ld+json">
{"description":"Introduction Bubble Shooter is a simple javascript game I made. To play the game go to this page. This is my report on the project. To see the report as a pdf, click here. Table of Contents Introduction Table of Contents Description Gameplay / Instructions Implementation Game Design Class Layout Shooter Design Grid Design Collision Detection Saving the Grid in Memory Contiguous Color Identification Algorithm Bubble Design Manager Design Future Improvements Development References Description Bubble Shooter is a simple game where a player shoots bubbles at a grid to make sets. A set is three or more contiguous bubbles of the same color. When a player taps on the screen or clicks with a mouse, a bubble will be fired at the grid and attach itself to the grid. Every few shots, an extra row will be added to the grid. For every few rows that are added to the grid, new colors will be added. When the number of colors is increased, the game becomes more difficult as it is harder to make sets of three. When the number of rows reaches a certain number, the player will lose. You are just attempting to get the highest score you can, there is no win condition. This project was developed using github and the project has its own github page. Gameplay / Instructions When starting a game, you will see a view like the image below. Below are the instruction for how to play the game. When playing the game, you need to shoot from the arrow and attach bubbles to the grid. The objective of the game is to stop the balls from expanding below the red line. If the grid expands below the red line, you lose. When you click, you fill fire a ball along the path of the arrow. To move the arrow move your mouse (or finger) on the screen. When you release the mouse, the shooter will fire a ball. After firing, the ball will attach to the grid. The next ball in the shooter queue will load into the shooter and a new ball will be added to the queue. If you shoot a ball at a wall, it will bounce off the walls If when you shoot a ball, it forms a set of three or more balls, they will pop. You receive points based on the number of balls in the set ( larget sets = more points). Bubbles will only pop when a bubble is added to the grid. If bubbles disconnect from the top row, they will also pop and give extra points. After a few shots (indicated by next) a new row will be added. This will push the other rows down. If the balls reach the red line, you will lose. As new rows are added, new colors will be added When the bubbles pass the red line, you lose. Press the “full” button at the bottom of the screen to make the game fullscreen That”s the basic rules and controls of the game. Good Luck! Implementation Game Design This game is made using javascript from scratch. The source code for this project can be found on github at https://github.com/nicholas-maltbie/BubbleShooterJS. This code utilizes a html canvas to create a scene and draw elements. The game uses a draw loop to redraw and update the game at a set interval. Each one of these draw loops represents a frame. The different elements of the game are added to a list and then drawn by the main draw loop; each element is responsible for drawing itself. This functionality along with some other core features are implemented in the bubble.js file. This method had a few flaws because when I wanted to control when elements were drawn. If I wanted the arrow to appear behind the balls, I needed to add it before the bubbles. This was not practical so I used a layer system to achieve this. When adding elements, I specified a layer. Then I used this information to control the order in which elements were drawn. I used a nested hash table, the first level is the list of layers and the second level is the elements in each layer. I used a hash map to achieve fast insertion and deletion. All items, when added to the hash, are assigned an arbitrary id so they can be indexed. Drawing elements is achieved through js and an HTML5 canvas. This allows for great flexibility and cross platform implementation that is easier than making the application in another editor. Class Layout Three main objects are added to the object list and control the game. Shooter - Bubble shooter that the user uses to fire bubbles Grid = Hex grid for bubbles in the game Manager - Game manager that controls interactions between different game elements [From now on, I use the terms bubble and ball interchangeably, they mean the same thing in context of the game. I used ball in the code because it was easier to type in the code] These are all represented by different classes and have additional classes to support them. One of the more prevalent objects in the project is ball. This is the colored bubble that can move across the screen and draw itself. Below is a diagram of the interactions between classes. Shooter Design The Shooter, Manager, Grid and Ball each have their own files that describe all the classes responsibilities. Each one of these files can be found on the github project page. These classes are used to operate the game. The Manager controls the game progress. The shooter has a state machine to control when the ball can fire. It continuously updates the position of the arrow and, when allowed, fires a ball. The Manager controls when the shooter can fire. This is driven by events in the game. The shooter is the main way that a user interacts with the game. This interaction is controlled by either a mouse or by touching the screen. The wait time for the shooter reload is determined by the manager. In the game, the reload happens half a second after the fired bubble collides with the grid. I wanted this game to be playable on the phone so I decided that it would be too costly to check for collisions with every ball. A simple solution for collision detection is to check for collisions between the moving ball and every other ball on the grid. If this is done every frame with a grid (14x22 at maximum) that totals to many (over 2,000) collision checks per frame. If this is supposed to run on a mobile device, this could be rather slow. Grid Design If the grid was a square grid, a simple solution would be to check the four locations that the ball is next to on the grid. The game uses a hex grid so this solution will not work. In order to resolve this for a hex grid, I found the location closest to the ball”s current location; then I took this location and checked for collisions with the adjacent locations. This is only 7 collision checks per frame in the worst case. Collision Detection After checking for collisions, if there is a collision, find the closest location out of the adjacent and nearest locations and attach the ball to the grid at that location. Below is a diagram to show this interaction. This is implemented in the intersect_grid function in grid. Saving the Grid in Memory After a ball attaches to the grid, the manager will tell the shooter to reload and add a ball to its queue. When the shooter is finished reloading, the manager will set the shooter in the ready state. I did not use a 2d array to represent the grid can be expanded in any direction when balls are attached, rows are added, or when bubbles are popped and removed. In order to achieve these requirements, I decided to use a hash map to save each bubble by its location. Contiguous Color Identification Algorithm When attaching bubbles to the grid, the game needs to detect for contiguous groups of bubbles. If there is a contiguous group of a specific color that at the location is larger than three, the bubbles need to be removed. In order to achieve this I used a flood algorithm that uses adjacency rules of a hex grid. I had a bit of difficulty implementing a flood algorithm with recursion so I used a stack and dictionary to track new locations without repeats. This is implemented in the color_food and flood methods in the grid class. All of these rules, methods and algorithms are implemented in the Grid.js file along with many more values. Majority of these extra values are used to control the grid on screen. In addition to the contiguous color method, there is also a contiguous ball method which does not use color as a factor. This method is used to determine if a group of balls should fall. If a bubble popping separates a group of bubbles so they are not connected to the top of the row, these disconnected bubbles need to be removed. This is handled in the verify grid method in the grid.js file. If the maximum row in a group of contiguous bubbles is not the highest row, all the bubbles in that group are removed. Bubble Design One of the most important elements in the game is the bubble (Also called a ball). This is a core element and is used directly or indirectly by all other elements in the game. The bubble is just a circle on the screen that has the ability to move. There is nothing very special about the bubble but this collection of functionally into one class is necessary to the development of the game. The bubble is shared across multiple files and used to communicate between classes. One example of this communication is between the Manager and shooter. The manager loads the shooter queue with bubbles. Then the shooter loads itself with bubbles from the queue. Manager Design The manager moderates all other interactions between elements within the game. As mentioned before, the manager controls the shooter directly. Additionally, the manager controls when new rows are added to the grid, decides when the player loses, and gives the player a score. This score is determined by user actions and when a fired shot collides with the grid. One difficulty I had to overcome was making the game fullscreen. By default the game canvas is rather small so I thought I could just scale the canvas size to overcome this. This worked well but I thought I could improve it even more by adding a full screen feature. I decided to just add a full button that the user could press to activate the fullscreen. I implemented this button in the canvas so the screen would look clean without any extra html. The difficult I had was that I could not set the screen to full screen without user input. The button was a scene object and indirectly received input from the user. To fix this, I added a new category of item, buttons. These buttons would receive direct input from the user when the user clicks on the canvas. This allowed me to overcome the problem of indirect interaction with the user. This will also work on mobile platforms but is a bit off as screen resolutions vary from device to device. The last major element the manager needed to moderate was the “You Lose” panel. This panel allowed the user to restart the game and showed the player”s score. This involved making a reset function. This function removes all elements from the game and then repeats the setup code. To make the screen look nice, I needed to add a round rect function that would draw a round rectangle on the screen. This is not a default feature in JS. I looked up the algorithm online and implemented the algorithm with the help of online sources. Future Improvements If I were to do this project again, I would have made a few changes. It”s not perfect and I hope to use these lessons in the future. One of my major problems was to put more effort into design. I implemented the grid and ball from internet tutorials as this was my first major project in javascript. I did not know what to expect and just hit the ground running. Even if these classes passed my initial requirements, the requirements changed over time because I did not do enough planning before I started working. Additionally, I would have made the mouse controls better defined. The mouse is just a variable that is controlled by the bubble.js file. This lead to future problems with getting direct user input to activate or deactivate fullscreen. If I had implemented this better I could have saved many hours of troubleshooting. In the future, I would like to add more game modes as this current version just supports one mode, lose after about 50 turns. I did not put much thought into balancing the game but it is still fun. My main objective was to create a game with js, not to make a perfect game. Hopefully I will be able to use this experience to improve my future projects. Development The entire development of the project can be found on the github page. This development has a commit log and notes for each addition to the project. I maintained development on a dev branch and merged to master whenever I made a noteworthy addition. Anyone can add the game to their own website with the following html commands. &lt;div align=&quot;center&quot;&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/bubblestyle.css&quot;&gt; &lt;/link&gt; &lt;canvas id=&quot;game-canvas&quot; style=&quot;margin:0 auto; background: #eee&quot; width=&quot;480&quot; height=&quot;320&quot;&gt;&lt;/canvas&gt; &lt;script type=&quot;application/javascript&quot; src=&quot;https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/grid.js&quot;&gt; &lt;/script&gt; &lt;script type=&quot;application/javascript&quot; src=&quot;https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/ball.js&quot;&gt; &lt;/script&gt; &lt;script type=&quot;application/javascript&quot; src=&quot;https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/shooter.js&quot;&gt; &lt;/script&gt; &lt;script type=&quot;application/javascript&quot; src=&quot;https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/manager.js&quot;&gt; &lt;/script&gt; &lt;script type=&quot;application/javascript&quot; src=&quot;https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/bubbles.js&quot;&gt; &lt;/script&gt; &lt;/div&gt; An example of this can be found on my own website here References chrisdavidmills, allisonlu, fscholz, gbharatwaj, end3r, Sheppy. “Bounce off the walls”. Mozilla Development Network. Game Development. Mar 14, 2016. (source) “What Is An HTML5 Canvas”. W3Schools. 2017. (source) “Implementation of Hex Grids”. Red Blob Games. May 6th, 2016. (source)","url":"https://nickmaltbie.com/bubble/report","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://nickmaltbie.com/bubble/report"},"headline":"Bubble Shooter Report","dateModified":"2017-04-01T00:00:00+00:00","datePublished":"2017-04-01T00:00:00+00:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <button onclick="topFunction()" id="myBtn" title="Go to top">Top</button>
  <script src="/assets/scripts/top_button.js"></script>

  <script src="/assets/lib/jquery.min.js"></script>
  <style>
    #cookie-notice {
        z-index: 10000;
        padding: 7px 15px;
        display: none;
        text-align: center;
        position: fixed;
        bottom: 0;
        background: #222;
        color: rgba(255,255,255,0.8);
    }
    #cookie-notice a {
        cursor: pointer;
        margin-left: 10px;
    }
    @media (max-width: 767px) {
        #cookie-notice span {display: block; padding-top: 3px; margin-bottom: 13px;}
        #cookie-notice a {position: relative; bottom: 4px;}
    }
    @media (min-width: 767px) {
        #cookie-notice {width: 100vw;}
    }
</style>
<div id="cookie-notice"><span>We would like to use third party cookies and scripts to improve the functionality of this website.</span><a id="cookie-notice-accept" class="btn btn-primary btn-sm">Approve</a><a href="/privacy.html" class="btn btn-primary btn-sm">Privacy Policy</a></div>
<script>
    function createCookie(name,value,days) {
        var expires = "";
        if (days) {
            var date = new Date();
            date.setTime(date.getTime() + (days*24*60*60*1000));
            expires = "; expires=" + date.toUTCString();
        }
        document.cookie = name + "=" + value + expires + "; path=/";
    }
    function readCookie(name) {
        var nameEQ = name + "=";
        var ca = document.cookie.split(';');
        for(var i=0;i < ca.length;i++) {
            var c = ca[i];
            while (c.charAt(0)==' ') c = c.substring(1,c.length);
            if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length,c.length);
        }
        return null;
    }
    function eraseCookie(name) {
        createCookie(name,"",-1);
    }

    if(readCookie('cookie-notice-dismissed')=='true') {

    } else {
        $('#cookie-notice').show();
    }
    $('#cookie-notice-accept').click(function() {
        createCookie('cookie-notice-dismissed','true',31);
        $('#cookie-notice').hide();
        location.reload();
    });

</script>

  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-134298967-1"></script>
<script>
	if(readCookie('cookie-notice-dismissed')=='true') {
	  	window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'UA-134298967-1');
	}
</script>


</head>
<body><header class="site-header" role="banner">

  <link href="https://fonts.googleapis.com/css?family=Roboto&display=swap" rel="stylesheet"/>

  <div class="header-wrapper"><a class="site-title" rel="author" href="/">Nick Maltbie</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          <a class="page-link" href="/">Home</a>
          <a class="page-link" href="/about.html">About Me</a>
          <a class="page-link" href="/blog.html">Blog</a>
          <a class="page-link" href="/professional.html">Professional</a>
          <a class="page-link" href="/honors.html">Honors</a>
        </div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
  <div class="wrapper">
    <header class="post-header">
  <h1 class="post-title p-name" itemprop="name headline">Bubble Shooter Report</h1>
  <p class="post-meta">
    <time class="dt-published" datetime="2017-04-01T00:00:00+00:00" itemprop="datePublished">Apr 1, 2017
    </time></p>
</header>

<div class="post-content e-content" itemprop="articleBody">
  <h1 id="introduction">Introduction</h1>

<p>Bubble Shooter is a simple javascript game I made. To play the game go to <a href="/bubble">this page</a>. This is my report on the project. To see the report as a pdf, click <a href="https://drive.google.com/file/d/0B0gCZqueOMVIWEZyQ0V4cmVTVDQ/view">here</a>.</p>

<h1 id="table-of-contents">Table of Contents</h1>

<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#table-of-contents">Table of Contents</a></li>
  <li><a href="#description">Description</a></li>
  <li><a href="#gameplay--instructions">Gameplay / Instructions</a></li>
  <li><a href="#implementation">Implementation</a>
    <ul>
      <li><a href="#game-design">Game Design</a></li>
      <li><a href="#class-layout">Class Layout</a></li>
      <li><a href="#shooter-design">Shooter Design</a></li>
      <li><a href="#grid-design">Grid Design</a>
        <ul>
          <li><a href="#collision-detection">Collision Detection</a></li>
          <li><a href="#saving-the-grid-in-memory">Saving the Grid in Memory</a></li>
          <li><a href="#contiguous-color-identification-algorithm">Contiguous Color Identification Algorithm</a></li>
        </ul>
      </li>
      <li><a href="#bubble-design">Bubble Design</a></li>
      <li><a href="#manager-design">Manager Design</a></li>
    </ul>
  </li>
  <li><a href="#future-improvements">Future Improvements</a></li>
  <li><a href="#development">Development</a></li>
  <li><a href="#references">References</a></li>
</ul>

<h1 id="description">Description</h1>

<p>Bubble Shooter is a simple game where a player shoots bubbles at a grid to make sets. A set is three or more contiguous bubbles of the same color. When a player taps on the screen or clicks with a mouse, a bubble will be fired at the grid and attach itself to the grid. Every few shots, an extra row will be added to the grid. For every few rows that are added to the grid, new colors will be added. When the number of colors is increased, the game becomes more difficult as it is harder to make sets of three. When the number of rows reaches a certain number, the player will lose. You are just attempting to get the highest score you can, there is no win condition. This project was developed using github and the project has its own <a href="https://github.com/nicholas-maltbie/BubbleShooterJS/">github page</a>.</p>

<h1 id="gameplay--instructions">Gameplay / Instructions</h1>

<p>When starting a game, you will see a view like the image below.</p>

<p><img src="/assets/projects/bubble/bubble-1.jpg" alt="Bubble Start" /></p>

<p>Below are the instruction for how to play the game.</p>

<p>When playing the game, you need to shoot from the arrow and attach bubbles to the grid. The objective of the game is to stop the balls from expanding below the red line.</p>

<p><img src="/assets/projects/bubble/bubble-2.jpg" alt="Instructions One" /></p>

<p>If the grid expands below the red line, you lose.</p>

<p><img src="/assets/projects/bubble/bubble-3.jpg" alt="Instructions Two" /></p>

<p>When you click, you fill fire a ball along the path of the arrow. To move the arrow move your mouse (or finger) on the screen. When you release the mouse, the shooter will fire a ball.</p>

<p><img src="/assets/projects/bubble/bubble-4.jpg" alt="Instructions Three" /></p>

<p>After firing, the ball will attach to the grid. The next ball in the shooter queue will load into the shooter and a new ball will be added to the queue.</p>

<p><img src="/assets/projects/bubble/bubble-5.jpg" alt="Instructions Four" /></p>

<p>If you shoot a ball at a wall, it will bounce off the walls</p>

<p><img src="/assets/projects/bubble/bubble-6.jpg" alt="Instructions Five" /></p>

<p>If when you shoot a ball, it forms a set of three or more balls, they will pop. You receive points based on the number of balls in the set ( larget sets = more points).</p>

<p><img src="/assets/projects/bubble/bubble-7.jpg" alt="Instructions Six" /></p>

<p>Bubbles will only pop when a bubble is added to the grid.</p>

<p><img src="/assets/projects/bubble/bubble-8.jpg" alt="Instructions Seven" /></p>

<p>If bubbles disconnect from the top row, they will also pop and give extra points.</p>

<p><img src="/assets/projects/bubble/bubble-9.jpg" alt="Instructions Eight" /></p>

<p>After a few shots (indicated by next) a new row will be added. This will push the other rows down. If the balls reach the red line, you will lose.</p>

<p><img src="/assets/projects/bubble/bubble-10.jpg" alt="Instructions Nine" /></p>

<p>As new rows are added, new colors will be added</p>

<p><img src="/assets/projects/bubble/bubble-11.jpg" alt="Instructions Ten" /></p>

<p>When the bubbles pass the red line, you lose.</p>

<p><img src="/assets/projects/bubble/bubble-12.jpg" alt="Instructions Eleven" />
<img src="/assets/projects/bubble/bubble-13.jpg" alt="Instructions Twelve" /></p>

<p>Press the “full” button at the bottom of the screen to make the game fullscreen</p>

<p><img src="/assets/projects/bubble/bubble-14.jpg" alt="Instructions Thirteen" /></p>

<p>That”s the basic rules and controls of the game. Good Luck!</p>

<h1 id="implementation">Implementation</h1>

<h2 id="game-design">Game Design</h2>

<p>This game is made using javascript from scratch. The source code for this project can be found on github at https://github.com/nicholas-maltbie/BubbleShooterJS. This code utilizes a html canvas to create a scene and draw elements. The game uses a draw loop to redraw and update the game at a set interval. Each one of these draw loops represents a frame. The different elements of the game are added to a list and then drawn by the main draw loop; each element is responsible for drawing itself. This functionality along with some other core features are implemented in the bubble.js file.</p>

<p><img src="/assets/projects/bubble/bubble-15.jpg" alt="Draw Loop Diagram" /></p>

<p>This method had a few flaws because when I wanted to control when elements were drawn. If I wanted the arrow to appear behind the balls, I needed to add it before the bubbles. This was not practical so I used a layer system to achieve this. When adding elements, I specified a layer. Then I used this information to control the order in which elements were drawn. I used a nested hash table, the first level is the list of layers and the second level is the elements in each layer. I used a hash map to achieve fast insertion and deletion. All items, when added to the hash, are assigned an arbitrary id so they can be indexed.</p>

<p><img src="/assets/projects/bubble/bubble-16.jpg" alt="Game Draw Diagram" /></p>

<p>Drawing elements is achieved through js and an HTML5 canvas. This allows for great flexibility and cross platform implementation that is easier than making the application in another editor.</p>

<h2 id="class-layout">Class Layout</h2>

<p>Three main objects are added to the object list and control the game.</p>

<ul>
  <li>Shooter - Bubble shooter that the user uses to fire bubbles</li>
  <li>Grid = Hex grid for bubbles in the game</li>
  <li>Manager - Game manager that controls interactions between different game elements</li>
</ul>

<p>[From now on, I use the terms <em>bubble</em> and <em>ball</em> interchangeably, they mean the same thing in context of the game. I used ball in the code because it was easier to type in the code]</p>

<p>These are all represented by different classes and have additional classes to support them. One of the more prevalent objects in the project is ball. This is the colored bubble that can move across the screen and draw itself. Below is a diagram of the interactions between classes.</p>

<p><img src="/assets/projects/bubble/bubble-17.jpg" alt="Game Draw Diagram" /></p>

<h2 id="shooter-design">Shooter Design</h2>
<p>The Shooter, Manager, Grid and Ball each have their own files that describe all the classes responsibilities. Each one of these files can be found on the <a href="https://github.com/nicholas-maltbie/BubbleShooterJS/">github project page</a>. These classes are used to operate the game. The Manager controls the game progress. The shooter has a state machine to control when the ball can fire. It continuously updates the position of the arrow and, when allowed, fires a ball. The Manager controls when the shooter can fire. This is driven by events in the game.</p>

<p>The shooter is the main way that a user interacts with the game. This interaction is controlled by either a mouse or by touching the screen.</p>

<p><img src="/assets/projects/bubble/bubble-18.jpg" alt="Shooter Diagram" /></p>

<p>The wait time for the shooter reload is determined by the manager. In the game, the reload happens half a second after the fired bubble collides with the grid. I wanted this game to be playable on the phone so I decided that it would be too costly to check for collisions with every ball. A simple solution for collision detection is to check for collisions between the moving ball and every other ball on the grid. If this is done every frame with a grid (14x22 at maximum) that totals to many (over 2,000) collision checks per frame. If this is supposed to run on a mobile device, this could be rather slow.</p>

<h2 id="grid-design">Grid Design</h2>

<p>If the grid was a square grid, a simple solution would be to check the four locations that the ball is next to on the grid. The game uses a hex grid so this solution will not work. In order to resolve this for a hex grid, I found the location closest to the ball”s current location; then I took this location and checked for collisions with the adjacent locations. This is only 7 collision checks per frame in the worst case.</p>

<h3 id="collision-detection">Collision Detection</h3>

<p>After checking for collisions, if there is a collision, find the closest location out of the adjacent and nearest locations and attach the ball to the grid at that location. Below is a diagram to show this interaction. This is implemented in the intersect_grid function in grid.</p>

<p><img src="/assets/projects/bubble/bubble-19.jpg" alt="Collision Detection Diagram" /></p>

<h3 id="saving-the-grid-in-memory">Saving the Grid in Memory</h3>

<p>After a ball attaches to the grid, the manager will tell the shooter to reload and add a ball to its queue. When the shooter is finished reloading, the manager will set the shooter in the ready state. I did not use a 2d array to represent the grid can be expanded in any direction when balls are attached, rows are added, or when bubbles are popped and removed. In order to achieve these requirements, I decided to use a hash map to save each bubble by its location.</p>

<p><img src="/assets/projects/bubble/bubble-20.jpg" alt="Grid Diagram" /></p>

<h3 id="contiguous-color-identification-algorithm">Contiguous Color Identification Algorithm</h3>

<p>When attaching bubbles to the grid, the game needs to detect for contiguous groups of bubbles. If there is a contiguous group of a specific color that at the location is larger than three, the bubbles need to be removed. In order to achieve this I used a flood algorithm that uses adjacency rules of a hex grid. I had a bit of difficulty implementing a flood algorithm with recursion so I used a stack and dictionary to track new locations without repeats. This is implemented in the color_food and flood methods in the grid class.</p>

<p><img src="/assets/projects/bubble/bubble-21.jpg" alt="Flood Diagram" /></p>

<p>All of these rules, methods and algorithms are implemented in the Grid.js file along with many more values. Majority of these extra values are used to control the grid on screen.</p>

<p>In addition to the contiguous color method, there is also a contiguous ball method which does not use color as a factor. This method is used to determine if a group of balls should fall. If a bubble popping separates a group of bubbles so they are not connected to the top of the row, these disconnected bubbles need to be removed. This is handled in the verify grid method in the grid.js file. If the maximum row in a group of contiguous bubbles is not the highest row, all the bubbles in that group are removed.</p>

<h2 id="bubble-design">Bubble Design</h2>

<p>One of the most important elements in the game is the bubble (Also called a ball). This is a core element and is used directly or indirectly by all other elements in the game. The bubble is just a circle on the screen that has the ability to move. There is nothing very special about the bubble but this collection of functionally into one class is necessary to the development of the game. The bubble is shared across multiple files and used to communicate between classes.</p>

<p>One example of this communication is between the Manager and shooter. The manager loads the shooter queue with bubbles. Then the shooter loads itself with bubbles from the queue.</p>

<h2 id="manager-design">Manager Design</h2>

<p>The manager moderates all other interactions between elements within the game. As mentioned before, the manager controls the shooter directly. Additionally, the manager controls when new rows are added to the grid, decides when the player loses, and gives the player a score. This score is determined by user actions and when a fired shot collides with the grid.</p>

<p>One difficulty I had to overcome was making the game fullscreen. By default the game canvas is rather small so I thought I could just scale the canvas size to overcome this. This worked well but I thought I could improve it even more by adding a full screen feature. I decided to just add a full button that the user could press to activate the fullscreen. I implemented this button in the canvas so the screen would look clean without any extra html. The difficult I had was that I could not set the screen to full screen without user input. The button was a scene object and indirectly received input from the user. To fix this, I added a new category of item, buttons. These buttons would receive direct input from the user when the user clicks on the canvas. This allowed me to overcome the problem of indirect interaction with the user. This will also work on mobile platforms but is a bit off as screen resolutions vary from device to device.</p>

<p>The last major element the manager needed to moderate was the “You Lose” panel. This panel allowed the user to restart the game and showed the player”s score. This involved making a reset function. This function removes all elements from the game and then repeats the setup code.</p>

<p>To make the screen look nice, I needed to add a round rect function that would draw a round rectangle on the screen. This is not a default feature in JS. I looked up the algorithm online and implemented the algorithm with the help of online sources.</p>

<h1 id="future-improvements">Future Improvements</h1>

<p>If I were to do this project again, I would have made a few changes. It”s not perfect and I hope to use these lessons in the future. One of my major problems was to put more effort into design. I implemented the grid and ball from internet tutorials as this was my first major project in javascript. I did not know what to expect and just hit the ground running. Even if these classes passed my initial requirements, the requirements changed over time because I did not do enough planning before I started working.</p>

<p>Additionally, I would have made the mouse controls better defined. The mouse is just a variable that is controlled by the bubble.js file. This lead to future problems with getting direct user input to activate or deactivate fullscreen. If I had implemented this better I could have saved many hours of troubleshooting.</p>

<p>In the future, I would like to add more game modes as this current version just supports one mode, lose after about 50 turns. I did not put much thought into balancing the game but it is still fun. My main objective was to create a game with js, not to make a perfect game.</p>

<p>Hopefully I will be able to use this experience to improve my future projects.</p>

<h1 id="development">Development</h1>

<p>The entire development of the project can be found on the <a href="https://github.com/nicholas-maltbie/BubbleShooterJS/">github page</a>. This development has a commit log and notes for each addition to the project. I maintained development on a dev branch and merged to master whenever I made a noteworthy addition.
Anyone can add the game to their own website with the following html commands.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">align=</span><span class="s">"center"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">"stylesheet"</span> <span class="na">type=</span><span class="s">"text/css"</span>
    <span class="na">href=</span><span class="s">"https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/bubblestyle.css"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;/link&gt;</span>
  <span class="nt">&lt;canvas</span> <span class="na">id=</span><span class="s">"game-canvas"</span> <span class="na">style=</span><span class="s">"margin:0 auto; background: #eee"</span> <span class="na">width=</span><span class="s">"480"</span> <span class="na">height=</span><span class="s">"320"</span><span class="nt">&gt;&lt;/canvas&gt;</span>
  <span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"application/javascript"</span>
    <span class="na">src=</span><span class="s">"https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/grid.js"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;/script&gt;</span>
  <span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"application/javascript"</span>
    <span class="na">src=</span><span class="s">"https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/ball.js"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;/script&gt;</span>
  <span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"application/javascript"</span>
    <span class="na">src=</span><span class="s">"https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/shooter.js"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;/script&gt;</span>
  <span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"application/javascript"</span>
    <span class="na">src=</span><span class="s">"https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/manager.js"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;/script&gt;</span>
  <span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"application/javascript"</span>
    <span class="na">src=</span><span class="s">"https://rawgit.com/nicholas-maltbie/BubbleShooterJS/master/bubbles.js"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</code></pre></div></div>

<p>An example of this can be found on my own website <a href="/game/2017/04/01/Bubble-Shooter.html">here</a></p>

<h1 id="references">References</h1>
<p>chrisdavidmills, allisonlu, fscholz, gbharatwaj, end3r, Sheppy. “Bounce off the walls”. Mozilla Development Network. Game Development. Mar 14, 2016. (<a href="https://developer.mozilla.org/en-US/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript/Bounce_off_the_walls">source</a>)</p>

<p>“What Is An HTML5 Canvas”. W3Schools. 2017. (<a href="https://www.w3schools.com/graphics/canvas_intro.asp">source</a>)</p>

<p>“Implementation of Hex Grids”. Red Blob Games. May 6th, 2016. (<a href="http://www.redblobgames.com/grids/hexagons/implementation.html">source</a>)</p>

</div><div id="disqus_thread"></div>
  <script>
    if(readCookie('cookie-notice-dismissed')=='true') {
      var disqus_config = function () {
        this.page.url = 'https://nickmaltbie.com/bubble/report';
        this.page.identifier = 'https://nickmaltbie.com/bubble/report';
      };

      (function() {
        var d = document, s = d.createElement('script');

        s.src = 'https://nickmaltbie.disqus.com/embed.js';

        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
      })();
    }
    else {
      document.getElementById('disqus_thread').innerHTML = "Please enable cookies to use comments section";
      document.getElementById('disqus_thread').className = "cookie-prompt";
    }
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript><a class="u-url" href="/bubble/report" hidden></a>

  </div>
</main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <ul class="contact-list">
          <li class="p-name">Nick Maltbie</li>
          <li>he/him/his</li><li><a class="u-email" href="mailto:nick.dmalt@gmail.com">nick.dmalt@gmail.com</a>.</li><li>Want to see the <a href="https://github.com/nicholas-maltbie/nick-jekyll">source code</a> of this website.</li>
          <li>View my site's <a class="decorated_link" href="/privacy.html">privacy policy.</a></li>
          <li>See the <a class="decorated_link" href="/references.html">references</a> page for referenced assets.</li>
        </ul>
      </div>

      <div class="footer-col"><ul class="social-media-list"><li>
    <a href="https://github.com/nicholas-maltbie" title="nicholas-maltbie">
      <img width=32px height=32px class="svg-icon" src="/assets/icons/github.svg" alt="github social link"></img>
    </a>
  </li><li>
    <a href="https://www.linkedin.com/in/nicholas-maltbie-b543a8137" title="nicholas-maltbie-b543a8137">
      <img width=32px height=32px class="svg-icon" src="/assets/icons/linkedin.svg" alt="linkedin social link"></img>
    </a>
  </li><li>
    <a href="https://www.twitter.com/NicholasMaltbie" title="NicholasMaltbie">
      <img width=32px height=32px class="svg-icon" src="/assets/icons/twitter.svg" alt="twitter social link"></img>
    </a>
  </li><li>
    <a href="https://www.reddit.com/u/flyQuixote" title="flyQuixote">
      <img width=32px height=32px class="svg-icon" src="/assets/icons/reddit.svg" alt="reddit social link"></img>
    </a>
  </li><li>
    <a href="https://www.youtube.com/channel/UCoGYwhYV-ar1d7b3niqqDQw" title="UCoGYwhYV-ar1d7b3niqqDQw">
      <img width=32px height=32px class="svg-icon" src="/assets/icons/youtube.svg" alt="youtube social link"></img>
    </a>
  </li></ul>
</div>"
    </div>

  </div>

</footer>


              <script>
                window.onload = function () {
                    var script = document.createElement('script');
                    var firstScript = document.getElementsByTagName('script')[0];
                    script.type = 'text/javascript';
                    script.async = true;
                    script.src = '/sw-register.js?v=' + Date.now();
                    firstScript.parentNode.insertBefore(script, firstScript);
                };
            </script>
            </body>


</html>
